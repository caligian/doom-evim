*doom-evim*

==============================================================================
CONTENTS *doom-toc*

1. Introduction |doom-introduction|
2. Philosophy   |doom-philosophy|
3. Filesystem   |doom-fs|
4. Modules      |doom-modules|
5. Keybindings  |doom-keybindings|
6. Snippets     |doom-snippets|
7. Treesitter   |doom-treesitter|
8. Help-editing |doom-help-editing|
9. Caveats      |doom-caveats|

==============================================================================
INTRODUCTION *doom-introduction*

Doom-evim seeks to not only emulate doom-emacs's features in some manner but
also try to make the vim experience a little-more emacsy. 

This distribution has been inspired by doom-nvim and doom-emacs both. You
should check them out in order to get a feel of how this distro would fare for
you.

Please read through the ENTIRE documentation in order to understand and use
doom efficiently.

==============================================================================
PHILOSOPHY *doom-philosophy*

The philosophy of doom-evim is similar to that emacs itself: DRY (Don't Repeat
Yourself). In implementation, this means that a good distro should allow the
user to use the distro's API themselves so that they can make their
configuration more manageable.

In order to prevent boilerplate code, doom comes with its own set of functions
which can allow you to do some complex configurations.

==============================================================================
FILESYSTEM *doom-fs*

This section will contain a brief description of doom-evim API. 
By default, user configs are not stored in the global table because the user
can do it by themselves if they wish to do so. 

*doom-system-fs*
Doom primarily uses fennel for its configuration. The compiled counterparts
are present in `~/.config/nvim/lua/`. Fennel itself is present in
`~/.config/nvim/lua/fennel.lua`. Therefore, it can be required anywhere in
doom's private configuration. 

These are the system modules: 
1. `init` 
    This module contains the required code to start doom. 
2. `utils`
    This module contains utility functions that can be used by doom and user
    both. Functions are accessible via |doom.utils|
3. `packages`
    This module takes into consideration the user list and only uses those
    packages along with their post and pre init configurations and creates a
    master list that is used by packer. 
4. `configs`
    This module contains all the configurations that are applied to doom AFTER
    packer initializes all the packages. It contains the majority of doom's
    keybindings.
5. `keybindings`
    This module contains all the non-package related keybindings. It also
    heavily utilizes `doom.utils`. It contains the majority of doom's
    general keybindings.  
6. `repl`
    This module contains a basic REPL for doom. It keeps tracks of the
    terminals user invokes and also provides some basic utilities such as
    sending strings to the REPL.
7. `runner`
    This module provides keybindings and commands to run operations such as
    compile, test, build, etc.
8. `specs`
    This module contains some packer configurations for packages before they
    are initialized by packer. This file is LOADED BEFORE PACKER loads the
    packages mentioned here. These packages should be present in doom.packages
9. `dap-config`
    This module configures vimspector to be used as a Debugger Adapter client
10. `logger`
    This is the global logger that doom uses to track startup errors.
11. `globals`
    This module contains the default configuration of doom. It can be
    overridden
    anywhere in the private/system configuration.
12. `vim-help`
    Some keybindings for easier editing in vim help files. 
13. `snippets`
    Enable easy snippet creation utilities for doom. This module sets up
    keybindings for the same.

*doom-user-fs*
Doom encourages the usage of `fennel` and `lua`  both for configuring the
private stuff of the user. However, some files should be defined in lua. This is
to prevent this distro from being too niche. 

These are the necessary lua files required:
1. `user-init`
    Contains doom configuration overrides as desired by the user. Also the
    starting point to require any additional user-defined modules in the
    private configuration.
2. `user-packages`
    Contains a master-list of packages that will be actually used by doom. This
    allows users to quickly re-enable or disable the default module declarations
    and also allow them to add their own plugins. 

    If you have messed up your package declarations in `user-packages.lua`, you
    can use the command `:CopyDefaultPackages` to copy default package declarations
    that arrive with doom.

3. `user-specs`
    Contains all the configuration that will be used in packer.use while
    initializing a package. These are NOT configurations that will be used AFTER
    but rather BEFORE all the packages are being in use. 

`lua/` and `fnl/` will contain everything that will later configure whatever the user has put
in doom. These are specially made for lua and fennel users sticking to their
guns. You can use a combination of both but I will recommend you to stick to one
language to avoid conflicts. 

Since `lua/` and `fnl/` are present in package.path, it is up to the user to
require and use them as they wish. Everything contained in `fnl/` will be
present in `compiled/` which contains the compiled lua files. 

Every file in `lua/` should be prefixed with `user-lua` and every file in `fnl/`
should be prefixed with `user-fnl` and then you can require them in your private
configuration. Keep in mind that only compiled files of fennel will be used.
They will usually seem like - `user-fnl-<NAME>.lua`. Example:
    You are in `user-init.lua` and want to import some fennel module. You have to
    type this: `require 'user-fnl-utils'` or `require 'user-lua-utils'`

Lastly, don't forget to add your fennel filenames to `doom.user_compile_fnl` or
else they won't be compiled before startup. You can also use: >

   doom.utils['convert-to-lua']([...]) -- Name of files present in fnl/

   -- or this
   (doom.utils.convert-to-lua [...])

to compile a list of files present in `~/.vdoom.d/fnl`. 

==============================================================================
MODULES *doom-modules*

This section contains the guide to use the doom api in your private
configuration. 

Most doom modules have functions that users won't need except `utils`,
`lsp-configs` and `logger`. 

*doom-globals*
Doom's globals are defined in globals.fnl. They can be accessed by indexing
doom when required, example: `doom.fnl_config = true`  

These are the configurable ones:

fnl_config {bool} 
    If set, compiles user fennel configurations files to lua. They can be
    required after compilation via prefix `user-fnl-<filename>`. 

    Default: true


default_runner {bool}
    If set, use utilities in |doom-runner|. Please visit the link to
    understand more about doom's runner. 

    Default: true

theme {str}
    Theme to set when doom starts. Default: PaperColor

    Tip: When you change the theme, press <leader>hrt to sync the statusline bg and fg with the current theme.

default_repl {bool}
    If set, use the REPL module provided with doom-evim. Please visit
    |doom-repl| for more information.

    Default: true


default_keybindings {bool}
    Set doom's defualt keybindings? 

    Default: true


default_package_configs {bool}
    Use doom's default package configuration? 

    Default: true


lisp_langs {list}
    These languages will have guns/vim-sexp package's functionality available
    to them. vim-sexp is similar to emacs's smartparens.

    Default: `["fennel" "clojure" "scheme"]`


treesitter_langs {list}
    Treesitter parser for these languages will be installed automatically.
    Only works if default_package_configs is true.

    Default: 
    >
        ["python" 
         "ruby"
         "json"
         "yaml"
         "javascript"
         "c"
         "lua"
         "fennel"
         "perl"]

map-help-groups {table}
    Contains the key-prefix descriptions for <leader> and <localleader> keys.
    Please check |doom.utils.register-to-wk| to understand what a key-prefix
    description is. 

    Default: 
    >
    {:leader {:b "Buffers"
              :q "Buffers+Close"
              :c "Commenting"
              :l "LSP"
              :h "Help+Telescope"
              :& "Snippets"
              "<space>" "Misc"
              :f "Files"
              :d "Debug"
              :x "Misc"
              :m "Filetype Actions"
              :s "Session"
              :g "Git"}
    :localleader {"," "REPL"
                  "t" "REPL"
                  "e" "REPL"}} 


user_compile_fnl {list}
    Filenames that will be compiled by |doom.utils.convert-to-lua| if no args
    are passed to it. 

    Default: `["init" "utils" "keybindings" "configs" "lsp-configs"]`


repl.ft {table} 
    Form: {<filetype> <repl-command>}
    These repl-commands will be used for the filetypes mentioned as keys in
    repl.ft

    Default:  
    >
        {:sh "bash"                  
         :ruby "irb"                 
         :perl "perl"                
         :fennel "fennel"            
         :python "python"            
         :lua "lua"                  
         :powershell "powershell"
         :ps1 "powershell"}

langs.<lang> {table} *doom.langs*
    Form: {<lang> <opts>}

    Please visit |doom-repl| to understand how doom's default debugger works
    and |doom-runner| to understand what compile, build and test is and
    |doom-lsp-configs| to understand how the key 'server' is used.

    <opts> accepts these keys: 
        {server:str} 
        Server name to use for this filetype

        {compile:str}
        Filetype async compiler command to use to run current file or anything
        else. 

        {manual:bool}
        Manually configure this language's LSP server. This server won't be
        setup using doom's defaults. 

        {debug:str}
        Debugger command to use with doom's REPL for ft. This splits the
        window and opens the debugger for the current file. It does not use
        DAP-protocol.

        {build:str}
        Filetype async cmd to build the current file or anything else. 

        {test:str}
        This command is used to run a test suite for the current file or
        anything else 

    Default: 
    >
        {:python {:server "pyright" 
                  :compile "python3"
                  :debug "python3 -m pdb"
                  :test "pytest"
                  :build false}

        :ruby {:server "solargraph"
               :compile "ruby"
               :debug "ruby -r debug"
               :test "rspec"
               :build "rake"}

        :lua {:server "sumneko_lua"
              :compile "/usr/bin/lua"
              :manual true
              :debug "lua"
              :test "lua"
              :build false}}


lsp.load_default {bool}
    If true, load all the default doom's lsp configurations. 

    Default: `false`


lsp.install_sumneko_lua {bool}
    If true, doom will automatically install and setup sumneko_lua. Requires
    the above to be set true.

    Default: `false`

lsp.servers {table}
    Form: {<server-name> <configuration>}
    If lsp.servers contains any configurations, it will be used to setup. If
    you use {} as config, doom will minimally set it up by itself.

    Default: 
    >
        {"solargraph" {} 
         "pyright"    {}}


*doom-utils*
Doom utils contain some functions that the user may use in their configuration. 
These functions are contained in `doom.utils`.
Lua users will have to use table indexing by string to access many of these functions
because their names contain '-'.

Lastly, if a param is wrapped in square brackets '[]', it means that the
param is optional. If the optional param is NOT AT THE END, you have to pass
nil in place of that param. If it is at the end, you can just skip passing it
altogether.

path-exists({path:str}) *doom.utils.path-exists*
    Returns true if path exists or false. 

    Returns: false or true

list-dir({path:str}) *doom.utils.list-dir*
    If path is valid, returns a table of children or false. 

    Returns: false or list


register({f:function}, {keybinding:bool}) *doom.utils.register*
    Creates a new global function under a random name and returns a string
    that can be used in command mode. 

    If keybinding is true then return a string that can be used in a
    keybinding. This is made separate because often commands used in
    keybindings contain '<CR>', etc that don't work in command mode.

    Returns: string


keys({t:table}) *doom.utils.keys*
    Returns all the keys in a table.

    Returns: list


vals({t:table}) *doom.utils.vals*
    Returns all the values in a table.

    Returns: list


consider-os({os-funcs:table}) *doom.utils.consider-os*
    Table form: {{os} {function}}

    If vim.has({os}) then the corresponding function is called. Return values
    of the function are returned. 

    Returns: anything returned from {function}


rest({v:list}) *doom.utils.rest*
    Returns all the elements except the first one in a list.

    Returns: list


first({v:list}) *doom.utils.first*
    Returns the first element of a list. 

    Returns: first element of {v}


find({t:list} {key:str}) *doom.utils.find*
    Returns the element found in {t} matched by {key}. {key} can be a valid
    regex string also. 

    Returns: Anything found in {t} matched {key}


join_path({[str]}) *doom.utils.join_path*
    List of strings will be concatenated with '/' and returned as a single
    string.

    Returns: string


confp({[str]}) *doom.utils.confp*
    Suffix `stdpath('config')` with list of strings passed ahead. 

    Example: confp('a', 'b', 'c') will return $HOME/.config/nvim/a/b/c

    Returns: string


sed({s:str} {replacement-a:list} {substitute-a:list}) *doom.utils.sed*
    Works like GNU sed. This replaces all the strings according to patterns mentioned in
    {replacement-a} with strings mentioned in {substitute-a}.

    Asserts: length(replacement-a) == length(substitute-a)

    Returns: string


linenum([{bufnr:int}]) *doom.utils.linenum*
   Returns the 1-indexed line number (this is the line number that you see) of
   the current buffer is {bufnr} is missing or line number of the buffer
   associated with bufnr. 

   Returns: integer


vpos([{bufnr:int}]) *doom.utils.vpos*
    Returns the starting and ending line number of the visual selection in a
    buffer mentioned by bufnr. If no bufnr is provided, the current buffer
    will be used. 

    Returns: list(int, int)


eval-at-line([{bufnr:int}] [{lineno:int}] {cmd:function/string}) *doom.utils.eval-at-line*
    If {bufnr} is missing, use current buffer. If {lineno} is missing, use
    current line number and execute {cmd} at that line. 

    If {cmd} is a function, the string representation will be obtained via
    |doom.utils.register| or if cmd is a string, use it as is. 

    Returns: nil


set-text([{bufnr:int}] {start-coordinates:list} {end-coordinates:list} {s:str/list}) *doom.utils.set-text*
    If {bufnr} is missing, use current buffer.

    {start-coordinates} and {end-coordinates} should be lists. 

    {s} should be a non-newline-containing string or a list of strings. The
    strings should not have a newlines. 

    The coordinates will be used to set the provided text in the buffer
    specified by default or provided value of {bufnr}.

    Form: 
    {start-coordinates} [<start-row> <start-column>]
    {end-coordinates}   [<end-row> <end-column>]
    {s}                 <string>/[<string>]

    Returns: 
    nil


set-lines([{bufnr:int}] {coordinates:list} {s:str/list}) *doom.utils.set-lines*
    Coordinates should be in the form: [<start-line> <end-line>]. String
    specification is the same as |doom.utils.set-text|. String[s] are set in
    the buffer specified by default or user value of {bufnr}.

    Returns: nil


save-excursion([{bufnr:int}] {f:function}) *doom.utils.save-excursion*
    Function will be executed in the buffer specified by {bufnr} and return
    the cursor position before that function is executed. 

    Returns: Anything from {f}


get-line-count([{bufnr:int}]) *doom.utils.get-line-count*
    Get the number of lines in buffer specified by default or user value of
    {bufnr}.

    Returns: integer


get-buf-name([{bufnr:int}]) *doom.utils.get-buf-name*
    Get the name of the current buffer or user value of {bufnr}.  

    Returns: string


buffer-string([{bufnr:int}] {coordinates:list} {concat:bool}) *doom.utils.buffer-string*
    Get the strings according to {coordinates} in the form: 
    [<start-line> <end-line>]. If {concat} is true then return a
    newline-concatened string obtained or return a table. 

    Returns: string/list


vtext([{concat:bool}]) *doom.utils.vtext*
    Get the text specified in visual selection. If {concat} is true, return a
    newline concateneted string. 

    Returns: string/list


line-range-exec({cmd:string/function}) *doom.utils.line-range-exec*
    Execute {cmd} on every line specified in a visual selection. 

    Returns: nil


respect-count({cmd:str/function} {newline:bool} {keybinding:bool}) *doom.utils.respect-count*
    This makes a command respect `v:count`. Basically a count can be specified
    for a command. If {newline} is true, the command is executed on the next
    consecutive lines. If not, the command will executed `v:count` times on the
    same line. If {keybinding} is true then return a string that can be used
    in a keybinding else return a string that can be command mode. 

    Returns: string


get-line([{bufnr:int}] [{lineno:int}]) *doom.utils.get-line*
    Returns the string at {lineno} in {bufnr}.  

    Returns: string

current-line({bufnr}) 
    Tagged as:
        *doom.utils.current-line*

    Description:
        Current string is obtained

    Params:
        {bufnr} Number

    Return:
        String

to-temp-buffer({s:str/list} {direction:str}) *doom.utils.to-temp-buffer*
    Open a window that exits as soon user leaves it. This window is split
    according to {direction} where the default direction is "sp" (split). 

    String specification is the same as |doom.utils.set-text|. 

    Returns: nil

     

sh({s:str} [{buf:bool}])  *doom.utils.sh*   
    Synchronously execute a bash command in {s}. If {buf} is true then open a
    temporary buffer and show the output else simply echo the output. Returns
    the output obtained. 

    Returns: string 

async-sh({s:str}) 
    Tagged as:
        *doom.utils.async-sh*

    Description:
        Asynchronously execute a bash command in {s}. If {buf} is true then
        open a temporary buffer and show output. 

    Params:
        {s} String        

    Return:
        nil
    

autocmd({group:str} {event:str} {pattern:str} {exec:str/function}) *doom.utils.autocmd*
    This is very similar to vim's `autocmd`. {group} is the name of the group
    to hook to {exec}. {event} is the triggering event of {exec}. Patterns
    pertaining to {event} are used to match the parameters to execute {exec}. 

    Returns: nil


augroup({name:str} [{autocmd-forms:list}]) *doom.utils.augroup*
    Create a new augroup and make autocmds based on this group if
    {autocmd-forms} is a list of parameters acceptable to
    |doom.utils.autocmd|. If no {autocmd-forms} exist then make an empty
    augroup.

    Returns: nil


add-hook([{groups:str/list}] [{events:str/list}] [{patterns:str/list}] {exec:str/function}) *doom.utils.add-hook*
    Doom recommends you to use this function instead of |doom.utils.autocmd|. 
    This function can be thought of |doom.utils.autocmd| on steriods. Multiple
    {groups}, {events} and {patterns} can be specified to use with {exec}.
    This function will create all the necessary autocmds for the user.

    Returns: nil


register-to-wk({keys:str} {help:str} [{help-desc:str}] [{not-register}]) *doom.utils.register-to-wk*
    Register to display in which-key popup at keypress. {keys} are normal key
    declarations without attributes that you would use in `map`. {help} is
    string to show for {keys}.

    If {help-desc} is specified, the prefix key for {keys} will also be
    documented in which-key popup. 

    If {not-register} is true then return the table that can be used with: 
    `require('which-key').register` manually by the user.

    Returns: nil or which-key table.
    
    
define-key({opts:table}) *doom.utils.define-key*   
    {opts} have the following keys:
        [{noremap:bool}] 
        Make a non-recursive keybinding? 
        Default: true

        [{key-attribs:list}]
        List of keybinding attributes such as `{buffer} {silent} ...`
        Just pass the name of the attribute or a list of attributes without
        the surround braces. eg "buffer" or ["buffer" "silent"]
        Default: silent

        {keys:str}
        Keys to map depending on {noremap} and {modes}

        [{modes:str/list}]
        Modes to bind to
        Default: ["n"]

        [{events:str/list}]
        Bind the keybinding to these events. This also requires {patterns} to
        be passed by the user.
        Default: nil. 

        [{patterns:str/list}]
        Make an event-based keybinding based on patterns acceptable to the
        bound event. This requires {events} to be passed.
        Default: nil

        [{groups:str/list}]
        These are the groups that an event-based keybinding will be bound to. 
        Default: nil. If {events} and {patterns} are set then "GlobalHook" is
        the default group sed.

        {exec:str/function}
        Use this str or function in the keybinding. 

        [{help:str}] 
        Help string to show in which-key popup
        Default: nil

        [{help-group:str}]
        Description of the prefix of {keys}
        Default: nil

        [{repeatable:bool}]
        Make the keybinding repeatable? 
        Default: false

    Returns: nil

     
define-keys({...}) *doom.utils.define-keys*
    Wrapper for |doom.utils.define-key| except that it can accept any number
    of forms in a list required by |doom.utils.define-key|.

    Returns: nil


convert-to-lua([{filename:list}])  *doom.utils.convert-to-lua*  
    This compiles the default or user fennel filenames present in `~/.vdoom.d/fnl`
to lua. The compiled file is saved in `~/.vdoom.d/compiled`.

    The default filenames are present in |doom.user_compile_fnl|.

    Returns: nil


try-then-else({try-f:function} {success-f:function} {failure-f:function})  *doom.utils.try-then-else*
    If {try-f} does not throw errors then {success-f} will be called and 
    its returns values will be returned else {failure-f} will be called and
    its return values will be returned.

    Returns: anything from {success-f} or {failure-f}


try-catch-then({try-f:function} {handle-f:function} [{then-f:function}])  *doom.utils.try-catch-then*
    If {try-f} emits an error then {handle-f} is used to handle it. 
    If {then-f} is passed, {then-f} is called at the end of handling.

    Returns: anything from {then-f} if it is supplied or nil


try-require({module-name} {type-module}) *doom.utils.try-require*   
    Try to require {module-name}. If it throws errors, the error is logged in
    `stdpath('data')/doom-evim.log`. {type-module} can be any string. doom
    uses "DOOM" for its error handling and by user modules use "USER".

    Returns: nil


get-user-input({prompt} {validate} {loop}) 
    Tagged as:
        *doom.utils.get-user-input* 

    Description:
        {prompt} is the string that is displayed while accepting input. {validate}
        is the function that shoudld a boolean value after processing the user
        input. If it returns true, the input is returned and if {loop} is
        false, get-user-input returns false. 

        If loop is true, {prompt} will be continued to be shown to the user until
        {validate} returns true with the input received.

    Params:
        {prompt} String
        {validate} Function
        {loop} Boolean

    Return:
        String or false


*doom-lsp-configs*
Module `lsp-configs` does not contain any useful functions that will be
required for general tasks. On the other hand, it contains some defaults that
can aid the users in setting up their LSP configuration quickly. 

Associated configuration:
    doom.lsp.install_sumneko_lua 
    doom.lsp.load_default 
    doom.lsp.servers

Functions available: 
    - on-attach-f 
      This function is used in initializing servers with nvim-lspconfig. You
      can use this function instead of copying the on-attach function from
      nvim-lspconfig's repo.

Other than that, this module sets up a bunch of keybindings to use with
neovim's builtin LSP. 

*doom-logger*
This modules presents 5 to use for logging. Doom's log file is present at
`stdpath('data')/doom-evim.log`.

log({level:str} {message:str}) *doom.logger.log*
    Level should one of debug, info, error, fatal or warn. Message should be a
    string to log. 

dlog({message:str})
    Translates to log(:debug, message)

elog({message:str})
    Translates to log(:error, message)

flog({message:str})
    Translates to log(:fatal, message)

ilog({message:str})
    Translates to log(:info message)

*doom-repl*
This module contains stuff to make doom's repl work. This module exposes some
functions which can be used by the user. Other than that, the module sets up a
couple of keybindings to <localleader>. It also provides a very basic debugger
which just splits the buffer and launches the script with its filetype's
associated debugger.

Associated configuration:
    doom.repl.ft 
    doom.repl.running_repls 

Associated commands:
    :REPLNew {cmd:str} *REPLNew*
        Start a new REPL using {cmd}
    
    :REPLSend {cmd:str} {s:str} *REPLSend*
        Send {cmd} associated REPL string {s} if it is not one of line, visual,
        till-point or buffer. 

        If {s} is
            :line       Send current line
            :till-point Send everything until cursor
            :visual     Send the visual selection
            :buffer     Send the whole buffer

    :REPLSplit {cmd:str} *REPLSplit*
        Split current window and launch and REPL using {cmd}. 
        If REPL has not been launched, it will done be so. 

    :REPLVsplit {cmd:str} *REPLVsplit*
        Vertically split current window and launch and REPL using {cmd}. 
        If REPL has not been launched, it will done be so. 

    :REPLTab {cmd:str} *REPLTab*
        Open REPL with {cmd} in a new tab. 

    :REPLTabShell *REPLTabShell*
        Equals :REPLTab bash

    :REPLVsplitShell *REPLVsplitShell* 
        Equals :REPLVsplit bash

    :REPLSplitShell *REPLSplitShell*
        Equals :REPLSplit bash

    :REPLShellSend {s:str} *REPLShellSend*
        Equals :REPLSend bash {s}

    :StartDebugger [{cmd:str}] *StartDebugger*
        Start a debugger with command {cmd}. If {cmd} is unspecified,
        `doom.langs.<filetype>.debug` will be queried to get the debugger for
        current filetype. If none is found, the command will fail.

    :SplitDebugger [{cmd:str}] *SplitDebugger*
        Command specifications are same as |StartDebugger|.
        Split current window and open terminal with the debugger.

    :VsplitDebugger [{cmd:str}] *VsplitDebugger*
        Command specifications are same as |StartDebugger|.
        Vertically split current window and open terminal with the debugger.
 
    :DebuggerSend {what:str} [{cmd:str}] *DebuggerSend*
        Command specifications are same as |StartDebugger|.
        {what} specifications are same as |REPLSend|
        Send {what} to debugger in a terminal.

    :KillDebugger [{cmd:str}] *KillDebugger*
        Command specifications are same as |StartDebugger|.
        {cmd} is used to get the running debugger to kill it.

    :GetDebugger *GetDebugger*
        Get the debugger for the current file.

Functions are analogous to commands except shutdown and shutdown-all.
Here are the mappings:

buffer-new -> |REPLNew|
    Also accepts an additional {id} parameter that is used to index the job id
    of the associated REPL.

split -> |REPLSplit|

vsplit -> |REPLVsplit|

tabnew -> |REPLTab|

shutdown {cmd:str}
    Shuts down the {cmd} associated REPL. 

shutdown-all
    Shuts down all REPLs

split-shell -> |REPLSplitShell|

vsplit-shell -> |REPLVsplitShell|

tabnew-shell -> |REPLTabShell|

... I suppose that you can figure out the rest of the mappings. 
You can check the source file yourself. It won't be that difficult. I promise.


*doom-runner*
Oftentimes you need to compile some stuff and you have to unnecessarily open
the terminal for that single task. doom-runner provides you with commands to
simply do that in an async job. 

There are 3 types of runners supported: 
    compile
        Used to compile the current file. Compile means simply running the
        current file using its interpreter.

    test
        Used to run suite tests. You can specify the base command and later
        provide additional args for the same. 

    build
        Used to build stuff. You can specify the base command and later
        provide additional args for the same. 

All the runners will be defined in |doom.langs|. If you want to simply compile
the current file then just add a {compile} key to |doom.langs|. 


*doom-packages*
This module has nothing the user can use. This module defines some keybindings
for doom's package manager packer and makes the final list to pass to packer
for initializing packages.

Associated globals:
    doom.packages [table]
        Contains the master list of all the packages passed to packer.startup

    doom.user_packages [table]
        Contains the table obtained from `user-packages.lua`.

Furthermore, `specs` and `user-specs` are also required which configure post
and pre package-init hooks. 

Associated functions:
    after! {packages:list/str} {f:function} *after!*
        If all the {packages} provided are present in doom.packages, {f} is
        called. This only occurs after all the packages are initialized.

    specs! {package:str} {t:table} *specs!*
        Configure a {package} using {t}. {t}'s specs should conform with
        `packer.use`.


*doom-dap*
This module sets up DAP with vimspector and sets up keybindings for the same. 

In order to start using DAP, you have to use the command `:VimspectorInstall`.
Pressing tab will show you which servers are available.

Doom configures these servers by default:
- local-lua-language (lua)
    Remember to put `require('lldebugger')` at the top of your lua file before
    pressing <leader>dd to start vimspector.

- vscode-node-debug2 (node/javascript)

- debugpy            (python)

Your vimspector filetype configurations are to be put in
`stdpath('data')/vimspector/<filetype>/default.json`

If you have not specified any then doom comes with its own configurations for
lua, python and javascript which will be used otherwise.
not one. These are present in
`~/.config/nvim/support/vimspector/<filetype>/default.json`

However, if there is a .vimspector.json in the workspace directory of the
script then nothing is copied and that file is used.

Keybindings:
>
    {:keys "<leader>dd" 
     :help "Start vimspector"}

    {:keys "<leader>dk"
     :help "Reset vimspector"}

    {:keys "<leader>dc"
     :help "Continue"}

    {:keys "<leader>db"
     :help "Toggle breakpoint"}

    {:keys "<leader>dT"
     :help "Clear breakpoints"}

    {:keys "<leader>dn"
     :help "Step over/next"}

    {:keys "<leader>df"
     :help "Step out/finish"}

    {:keys "<leader>ds"
     :help "Step in/step"}

*doom-default-packages*
These are the packages that are shipped with doom. Only the essentials are
installed and the rest are installed by :PackerInstall at first startup.

Master list is available in `~/.config/nvim/lua/default_packages.lua`

*doom-package-groups*
Doom uses groups of these packages to configure a certain functionality. Many
times if you remove even one package, an entire functionality won't be
working. These are the groups used: 

    Doom's LSP configuration: >
        nvim-lspconfig 
        nvim-treesitter
        nvim-lsp-installer
        nvim-cmp
        cmp-nvim-lsp
        cmp-vsnip
        vim-vsnip
        trouble.nvim
        cmp-buffer
        cmp-path
        cmp-cmdline
<
    Doom's telescope configuration: >
        telescope.nvim
        telescope-project.nvim
        telescope-file-browser.nvim
<
Rest of the packages are not configured in groups.


==============================================================================
KEYBINDINGS *doom-keybindings*

Keybindings are quite easy to make. You have to use |doom.utils.define-key| for a
single keybinding and |doom.utils.define-keys| for binding multiple keys. 

Additionally, you can make keybindings respect v:count or work on a range of
lines in a visual selection. 

In order to do the latter you have to use this form in 'exec' 
>
    -- lua
    exec = function() doom.utils["line-range-exec"](<function>) end

    -- fennel
    :exec #(doom.utils.line-range-exec <function>)

In order to do the former, use this form in 'exec'
>
    -- lua
    exec = doom.utils["respect-count"](<function/string>)

    -- fennel
    :exec (doom.utils.respect-count <function/string>)

Below are the list of default keybindings that doom comes with.

Font operations:
>
    {:keys "<C-ScrollWheelUp>"
     :help "Increase font size by 2}

    {:keys "<C-ScrollWheelDown>"
     :help "Decrease font size by 2}

Colorscheme:
>
    {:keys "<leader>hrt"
     :help "Reload statusline theme."}

File operations: 
>
    {:keys "<leader>fs"
     :help "Save curent file"}
    
    {:keys "<leader>fv"
     :help "Source current file"}
    
    {:keys "<leader>fp"
     :help "Open doom config dir"}
    
    {:keys "<leader>fP"
     :help "Open private config dir"}
    
    {:keys "<leader>fV"
     :help "Source doom's init.lua"}
<
Tab operations:
>
    {:keys "<leader>tk"
     :help "Close current tab"}
    
    {:keys "<leader>tn"
     :help "Go to next tab"}
    
    {:keys "<leader>tp"
     :help "Go to previous tab"}
    
    {:keys "<leader>tf"
     :help "Find tab"}
    
    {:keys "<leader>te"
     :help "Open file in a new tab"}
    
    {:keys "<leader>tt"
     :help "Open a new tab"}
<    
Buffer operations:
>
    {:keys "<leader>qw"
     :help "Save buffers and quit"}
    
    {:keys "<leader>bp"
     :help "Previous buffer"}

    {:keys "<leader>bR"
     :help "Set file to RO"}
    
    {:keys "<leader>bn"
     :help "Next buffer"}
    
    {:keys "<leader>br"
     :help "Revert buffer"}
    
    {:keys "<leader>bk"
     :help "Hide current buffer"}
    
    {:keys "<leader>qq"
     :help "Quit unconditionally"}
    
    {:keys "<del>"
     :help "No highlight"}
<
Misc operations:
>
    {:keys "<leader>;"
     :help "Open command mode"}
    
    {:keys "<localleader>&"
     :help "Execute an async sh command and split window"}
<
    
Clipboard operations:
>
    {:keys "<leader>xp"
     :help "Paste from clipboard"

    {:keys "<leader>hrr"
     :help "Reload doom"}
                     
Indentation:
>
     {:keys "<PageDown>"
      :help "Decrease indent"}

     {:keys "<PageUp>"
      :help "Increase indent"}

     {:keys "<S-PageDown>"
      :modes ["v"]
      :help "Decrease indent in range"}

     {:keys "<S-PageUp>"
      :modes ["v"]
      :help "Increase indent in range"}

Doom REPL:
>
    {:keys "<localleader>,t"
     :help "Open a ft REPL in a new tab"}
    
    {:keys "<localleader>,T"
     :help "Open a new bash REPL in a new tab"}
    
    {:keys "<localleader>mee"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>me."
     :help "Send strings till-point to ft REPL"}
    
    {:keys "<localleader>meb"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>meE"
     :help "Send current line to bash REPL"}
    
    {:keys "<localleader>me>"
     :help "Send strings till-point to bash REPL"}
    
    {:keys "<localleader>meB"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>meE"
     :modes "v"
     :help "Send visual range to bash REPL"}
    
    {:keys "<localleader>mee"
     :modes "v"
     :help "Send visual range to ft REPL"}
    
    {:keys "<localleader>ts" 
     :help "Split buffer and open shell"}
    
    {:keys "<localleader>tv" 
     :help "Split buffer and open shell"}
    
    {:keys "<localleader>,s" 
     :help "Split buffer and open ft REPL"}
    
    {:keys "<localleader>,v" 
     :help "Vsplit buffer and open ft REPL"}
    
    {:keys "<localleader>,k"
     :help "Shutdown current ft REPL"}
    
    {:keys "<localleader>,K"
     :help "Shutdown all REPLs"}
    
    {:keys "<localleader>tk"
     :help "Shutdown bash shell"}

Doom runner:
>
    {:keys "<leader>mC" 
     :help "Compile <lang>"}

    {:keys "<leader>mB"
     :help "Build <lang>"}

    {:keys "<leader>mT"
     :help "Test <lang>"}

    {:keys "<leader>mc"
     :help "Compile buffer file"}

    {:keys "<leader>mb"
     :help "Build buffer file"}

    {:keys "<leader>mt"
     :help "Compile buffer file"}

nvim-tree.lua:
>
    {:keys "<leader>`" 
     :help "Open nvim-tree" }

vimspector:
>
    {:keys "<leader>de"
     :help "Reset vimspector"}
    
    {:keys "<leader>dc"
     :help "Continue"}
    
    {:keys "<leader>dt"
     :help "Toggle breakpoint"}
    
    {:keys "<leader>dT"
     :help "Clear breakpoints"}
    
    {:keys "<leader>dk"
     :help "Restart vimspector"}
    
    {:keys "<leader>dh"
     :help "Step out/finish"}
    
    {:keys "<leader>dl"
     :help "Step in/step"}
    
    {:keys "<leader>dj"
     :help "Step over/next"}

persistence.nvim:
>
    {:keys "<leader>sl"
     :help "Load session"}
    
    {:keys "<leader>ss"
     :help "Load session"}

trouble.nvim:
>
    {:keys "<leader>lt" 
     :help "Toggle trouble"}

zen-mode.nvim
>
    {:keys "<leader>bz" 
     :help "Activate ZenMode"}

telescope.nvim, 
telescope-project.nvim,
telescope-file-browser.nvim:
>
    {:keys "<leader>ff"
     :help "Find file"}
    
    {:keys "<localleader>/"
     :help "Live grep in cwd"}
    
    {:keys "<leader>/"
     :help "Grep string in cwd"}
    
    {:keys "<leader>fg"
     :help "Show git files"}
    
    {:keys "<leader>hk"
     :help "Show keymaps"}
    
    {:keys "<leader>ht"
     :help "Select theme"}
    
    {:keys "<leader>bb"
     :help "Show buffers"}
    
    {:keys "<leader>fr"
     :help "Show old files"}
    
    {:keys "<A-x>"
     :help "Show commands"}
    
    {:keys "<leader>hr"
     :help "Show command history"}
    
    {:keys "<leader>sr"
     :help "Show search history"}
    
    {:keys "<leader>hm"
     :help "Show man page for a program"}
    
    {:keys "<leader>hj"
     :help "Show jumplist"}
    
    {:keys "<leader>h\""
     :help "Show all registers"}
    
    {:keys "<M-y>"
     :help "Show all registers"}
    
    {:keys "<leader><leader>s"
     :help "Resume telescope"}
    
    {:keys "<leader>hq"
     :help "Show quickfix list"}
    
    {:keys "<leader>lhr"
     :help "Show references"}
    
    {:keys "<leader>lhs"
     :help "Document symbols"}
    
    {:keys "<leader>lhw"
     :help "Show workspace symbols"}
    
    {:keys "<leader>lhW"
     :help "Show dynamic ws symbols"}
    
    {:keys "<leader>lhc"
     :help "Show code actions"}
    
    {:keys "<leader>lhr"
     :help "Show range code actions"}
    
    {:keys "<leader>lhd"
     :help "Show diagnostics"}
    
    {:keys "<leader>lhi"
     :help "Show LSP implementations"}
    
    {:keys "<leader>lhd"
     :help "Show LSP definitions"}
    
    {:keys "<leader>lht"
     :help "Show type definitions"}
    
    {:keys "<leader>mhs"
     :help "Show treesitter symbols"}
    
    {:keys "<leader>ghc"
     :help "Show commits"}
    
    {:keys "<leader>ghC"
     :help "Show branch commits"}
    
    {:keys "<leader>ghb"
     :help "Show branches"}
    
    {:keys "<leader>ghs"
     :help "Show status"} 
   
    {:keys "<leader>ghS"
     :help "Show stashes"}
    
    {:keys "<leader>fF"
     :help "Open file browser"}
    
    {:keys "<leader>pp"
     :help "Open project"}

tagbar:
>
    {:keys "<C-t>"
     :exec ":TagbarToggle<CR>"}

vim-fugitive:
>
    {:keys "<leader>gg" 
     :help "Open Fugitive in cwd"}
    
    {:keys "<leader>gi" 
     :help "Initialize git in cwd"}
    
    {:keys "<leader>ga" 
     :help "Track current file"}
    
    {:keys "<leader>gs" 
     :help "Stage current file"}
    
    {:keys "<leader>gc" 
     :help "Commit changes"}
    
    {:keys "<leader>gp" 
     :help "Push commits"}
    
    {:keys "<leader>gm" 
     :help "Merge from remote"}

nvim-luapad:
>
    {:keys "<F3>"
     :help "Start Luapad"}

vim-bbye:
>
    {:keys "<leader>bq"
     :help "Delete current buffer"}


vim-vsnip:
>
    {:keys "<C-j>"
     :noremap false
     :modes "s"
     :key-attribs "expr"
     :help "Expand snippet"}

    {:keys "<C-j>"
     :noremap false
     :modes "i"
     :key-attribs "expr"
     :help "Expand snippet"}

    {:keys "<C-l>"
     :modes "s"
     :key-attribs "expr"
     :noremap false
     :help "Expand or jump snippet"}

    {:keys "<C-l>"
     :modes "i"
     :noremap false
     :key-attribs "expr"
     :help "Expand or jump snippet"}

    {:keys "<S-Tab>"
     :noremap false
     :key-attribs "expr"
     :modes "i"
     :help "Snippet jump to next field"}

    {:keys "<S-Tab>"
     :key-attribs "expr"
     :noremap false
     :modes "i"
     :help "Snippet jump to prev field"}

    {:keys "<Tab>"
     :noremap false
     :key-attribs "expr"
     :modes "s"
     :help "Snippet jump to next field"}

    {:keys "<Tab>"
     :key-attribs "expr"
     :noremap false
     :modes "i"
     :help "Snippet jump to next field"}


==============================================================================
SNIPPETS *doom-snippets*
This section explains snippet creation in doom-evim. 

Doom-evim uses vim-vsnip. As it turns out, it is not easily possible to simply
copy paste into a JSON and not throw errors. Therefore, in the spirit of
YASnippet, doom provides some keybindings to make this task easy for you. 
Simply press:
    `<leader>&ns` (for split window)
    `<leader>&nv` (for vsplit window)

This will [v]split your current window. Now enter your snippet in the same
manner as you would in vscode or emacs and press `gx`. 

Pressing `gx` will prompt you for the name, prefix and description of the
snippet. Once you are done entering all that, voila! Your snippet has been
registered.

There are other convenient keybindings too: 
    `<leader>&es `Edit a filetype snippets list json in a split window 
    `<leader>&ev `Edit a filetype snippets list json in a vsplit window 

==============================================================================
TREESITTER *doom-treesitter*

This section only covers some of the additional features that users can use
and not even be aware of it. Doom ships with
`nvim-treesitter-textobjects` which make it easy to select nodes and do other
operations. 

Doom creates some textobjects of its own. If you want to see the potential of
this, try using the textobjects with an REPL.

Textobjects mappings:
>
       {:ib  "@block.inner"
        :ab  "@block.outer"

        :iC  "@call.inner"
        :aC  "@call.outer"

        :ic  "@class.inner"
        :ac  "@class.outer"

        "a;"  "@comment.outer"

        :iF  "@conditional.inner"
        :aF  "@conditional.outer"

        :if  "@function.inner"
        :af  "@function.outer"

        :il  "@loop.inner"
        :al  "@loop.outer"

        :ip  "@parameter.inner"
        :ap  "@parameter.outer"}

Other mappings:
    `]m` Go to the start of next function
    `]]` Go to the start of the next class

    `]M` Go to the end of next function
    `][` Go to the end of next class

    `[m` Go to the start of previous function
    `[[` Go to the start of previous class

    `[M` Go to the end of previous function
    `[]` Go to the end of previous class


==============================================================================
HELP-EDITING *doom-help-editing*

This section explains the functionality provided by doom to edit vim help
files. The heart of this functionality depends on `vim-help`.

What this module does is make it easier for the user to navigate around in vim
help files. The keybindings would do a better job at explaining to you: >

   {:keys "<C-f>"
    :key-attribs "buffer"
    :help "Jump to next section"
    :patterns ["*txt,*text"]
    :events "BufEnter"}

   {:keys "<C-b>"
    :key-attribs "buffer"
    :help "Jump to prev section"
    :patterns ["*txt,*text"]
    :events "BufEnter"}

   {:keys "-" 
    :help "Add separator based on textwidth"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]}

   {:keys "+" 
    :help "Readjust the width of sep across the buffer"
    :events ["BufEnter"]
    :key-attribs ["buffer"]
    :patterns ["*txt,*text"]}

   {:keys "<A-u>"
    :key-attribs ["buffer"]
    :help "Convert current word to url"
    :events ["BufEnter"]
    :patterns ["*txt,*text"]}

   {:keys "<A-t>"
    :help "Convert current word to tag"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]}

   {:keys "<C-p>"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]
    :help "Goto prev url"}

   {:keys "<C-n>"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]
    :help "Goto next url"}

   {:keys "<A-f>"
    :help "Goto next tag"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]}

   {:keys "<A-b>"
    :help "Goto prev tag"
    :key-attribs ["buffer"]
    :events ["BufEnter"]
    :patterns ["*txt,*text"]}

Tags are words enclosed between 2 '*' and urls are words enclosed between two
'|'. 

Hopefully this should encourage you to write your own help docs.

==============================================================================
CAVEATS *doom-caveats*

This section contains some caveats that users should keep in mind:

Regarding user fennel configuration:
    - Do not use modules in your configuration files. 
      For some reason, fennel is unable to compile the module string. 
      Simply make a local var and then return it at the end of the file.

Regarding private configuration:
    Under any circumstances, ensure that `user-packages.lua`  is present in
    the file path. Without this file, doom will crash.

Regarding doom's configuration:
    - Do not modify global variables unnecessarily if you don't know what they
      do. If you are a new user, better stick to the ones already defined in
      |doom-globals|.

Regarding packages:
    - Any packages added or removed will be quickly reflected after you start
      doom. Do not remove the essentials or else doom will fail to start. 
    - Keep in mind |doom-package-groups| while removing packages

Regarding LSP:
    - Default LSP can be disabled and other LSP clients can be used. That's
      OK. However, you won't get any nvim-cmp functionality either. So keep
      that in mind. 

