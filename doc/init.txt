*doom-evim*

==========================================================================
CONTENTS *doom-toc*

1. Introduction  |doom-introduction|
2. Philosophy |doom-philosophy|
3. Filesystem |doom-fs|
4. Modules  |doom-modules|
5. Keybindings |doom-keybindings|
6. Caveats |doom-caveats|

==========================================================================
INTRODUCTION *doom-introduction*

Doom-evim seeks to not only emulate doom-emacs's features in some manner but
also try to make the vim experience a little-more emacsy. 

This distribution has been inspired by doom-nvim and doom-emacs both. You
should check them out in order to get a feel of how this distro would fare for
you.

==========================================================================
PHILOSOPHY *doom-philosophy*

The philosophy of doom-evim is similar to that emacs itself: DRY (Don't Repeat
Yourself). In implementation, this distribution of nvim provides everything to
the user and by everything, I mean everything doom itself is using. This means
that if the user wishes to make something complex in their configuration, the
framework's composition should aid the user as if the user is extending the
distribution itself. In simple words, many useful functions used by doom-evim
are available to a user and the distribution sets good reusable defaults. 

If you wish to extend this configuration, feel free to do so via your private
`~/.vdoom.d`. You can do the same via `lua` or `fennel`.

==========================================================================
FILESYSTEM *doom-fs*

This section will contain a brief description of doom-evim API. 
By default, user configs are not stored in the global table because the user
can do it by themselves if they wish to do so. 

*doom-system-fs*
Doom primarily uses fennel for its configuration. The compiled counterparts
are present in `~/.config/nvim/lua/`. Fennel itself is present in
`~/.config/nvim/lua/fennel.lua`. Therefore, it can be required anywhere in
doom's private configuration. 

These are the system modules: 
1. `init` 
    This module contains the required code to start doom. 
2. `utils`
    This module contains utility functions that can be used by doom and user
    both. Functions are accessible via |doom.utils|
3. `package-utils`
    This module contains utility functions to store packages. It takes into
    consideration user package declarations also. It also creates the final
    list of packer forms for packer usage. 

    It also contains the default package declarations. This is the exact
    declaration that will be present in `~/.vdoom.d/user-packages.lua`. 
4. `packages`
    This module imports stuff from package-utils and initializes packer.
    Currently, there is no way to reload packages on the fly because packer is
    called only once to configure doom. Therefore, the user has to restart
    nvim everytime they modify `~/.vdoom.d/user-packages.lua`.
5. `configs`
    This module contains all the configurations that are applied to doom AFTER
    packer initializes all the packages. It contains the majority of doom's
    keybindings.
6. `keybindings`
    This module contains all the non-package related keybindings. It also
    heavily utilizes `doom.utils`. It contains the majority of doom's
    general keybindings.  
7. `repl`
    This module contains a basic REPL for doom. It keeps tracks of the
    terminals user invokes and also provides some basic utilities such as
    sending strings to the REPL.
8. `runner`
    This module provides keybindings and commands to run operations such as
    compile, test, build, etc.
9. `specs`
    This module contains some packer configurations for packages before they
    are initialized by packer. This file is LOADED BEFORE PACKER loads the
    packages mentioned here. These packages should be present in doom.packages
10. `dap-config`
    This module configures vimspector to be used as a Debugger Adapter client
11. `logger`
    This is the global logger that doom uses to track startup errors.
12. `globals`
    This module contains the default configuration of doom. It can be
    overridden
    anywhere in the private/system configuration.
13. `vim-help`
    Some keybindings for easier editing in vim help files. Planning to add
    more features

*doom-user-fs*
Doom encourages the usage of `fennel` and `lua`  both for configuring the
private stuff of the user. However, some files should be defined in lua. This is
to prevent this distro from being too niche. 

These are the necessary lua files required:
1. `user-init`
    Contains doom configuration overrides as desired by the user. Also the
    starting point to require any additional user-defined modules in the
    private configuration.
2. `user-packages`
    Contains a master-list of packages that will be actually used by doom. This
    allows users to quickly re-enable or disable the default module declarations
    and also allow them to add their own plugins. 
3. `user-specs`
    Contains all the configuration that will be used in packer.use while
    initializing a package. These are NOT configurations that will be used AFTER
    but rather BEFORE all the packages are being in use. 

`lua/` and `fnl/` will contain everything that will later configure whatever the user has put
in doom. These are specially made for lua and fennel users sticking to their
guns. You can use a combination of both but I will recommend you to stick to one
language to avoid conflicts. 

Since `lua/` and `fnl/` are present in package.path, it is up to the user to
require and use them as they wish. Everything contained in `fnl/` will be
present in `compiled/`which contains the compiled lua files. 

Every file in `lua/` should be prefixed with `user-lua` and every file in `fnl/`
should be prefixed with `user-fnl` and then you can require them in your private
configuration. Keep in mind that only compiled files of fennel will be used.
They will usually seem like - `user-fnl-<NAME>.lua`. 

Lastly, don't forget to add your fennel filenames to `doom.user_compile_fnl` or
else they won't be compiled before startup. You can also use: >

   doom.utils['convert-to-lua']([...]) -- Name of files present in fnl/

   -- or this
   (doom.utils.convert-to-lua [...])

to compile a list of files present in `~/.vdoom.d/fnl`. 

==========================================================================
MODULES *doom-modules*

This section contains the guide to use the doom api in your private
configuration. 

Most doom modules have functions that users won't need except `utils`,
`lsp-configs` and `logger`. 

*doom-globals*
Doom's globals are defined in globals.fnl. They can be accessed by indexing
doom when required, example: `doom.fnl_config = true`  

These are the configurable ones:

fnl_config {bool} 
    If set, compiles user fennel configurations files to lua. They can be
    required after compilation via prefix `user-fnl-<filename>`. 

    Default: true


default_runner {bool}
    If set, use utilities in |doom-runner|. Please visit the link to
    understand more about doom's runner. 

    Default: true


default_repl {bool}
    If set, use the REPL module provided with doom-evim. Please visit
    |doom-repl| for more information.

    Default: true


default_keybindings {bool}
    Set doom's defualt keybindings? 

    Default: true


default_package_configs {bool}
    Use doom's default package configuration? 

    Default: true


lisp_langs {list}
    These languages will have guns/vim-sexp package's functionality available
    to them. vim-sexp is similar to emacs's smartparens.

    Default: ["fennel" "clojure" "scheme"]


treesitter_langs {list}
    Treesitter parser for these languages will be installed automatically.
    Only works if default_package_configs is true.

    Default: ["python" 
              "ruby"
              "json"
              "yaml"
              "javascript"
              "c"
              "lua"
              "fennel"
              "perl"]


map-help-groups {table}
    Contains the key-prefix descriptions for <leader> and <localleader> keys.
    Please check |doom.utils.register-to-wk| to understand what a key-prefix
    description is. 

    Default: {:leader {:b "Buffers"
                       :q "Buffers+Close"
                       :c "Commenting"
                       :l "LSP"
                       :h "Help+Telescope"
                       :f "Files"
                       :d "Debug"
                       :x "Misc"
                       :m "Filetype Actions"
                       :s "Session"
                       :g "Git"}

              :localleader {"," "REPL"
                            "t" "REPL"
                            "e" "REPL"}} 


user_compile_fnl {list}
    Filenames that will be compiled by |doom.utils.convert-to-lua| if no args
    are passed to it. 

    Default: ["init" "utils" "keybindings" "configs" "lsp-configs"]


repl.ft {table} 
    Form: {<filetype> <repl-command>}
    These repl-commands will be used for the filetypes mentioned as keys in
    repl.ft

    Default: {:sh "bash"
              :ruby "irb"
              :perl "perl"
              :fennel "fennel"
              :python "python"
              :lua "lua"
              :powershell "powershell"
              :ps1 "powershell"}


langs.<lang> {table} *doom.langs*
    Form: {<lang> <opts>}

    Please visit |doom-repl| to understand how doom's default debugger works
    and |doom-runner| to understand what compile, build and test is and
    |doom-lsp-configs| to understand how the key 'server' is used.

    <opts> accepts these keys: 
        {server:str} 
        Server name to use for this filetype

        {compile:str}
        Filetype async compiler command to use to run current file or anything
        else. 

        {manual:bool}
        Manually configure this language's LSP server. This server won't be
        setup using doom's defaults. 

        {debug:str}
        Debugger command to use with doom's REPL for ft. This splits the
        window and opens the debugger for the current file. It does not use
        DAP-protocol.

        {build:str}
        Filetype async cmd to build the current file or anything else. 

        {test:str}
        This command is used to run a test suite for the current file or
        anything else 

    Default: {:python {:server "pyright" 
                       :compile "python3"
                       :debug "python3 -m pdb"
                       :test "pytest"
                       :build false}

              :ruby {:server "solargraph"
                     :compile "ruby"
                     :debug "ruby -r debug"
                     :test "rspec"
                     :build "rake"}

              :lua {:server "sumneko_lua"
                    :compile "/usr/bin/lua"
                    :manual true
                    :debug "lua"
                    :test "lua"
                    :build false}}


lsp.load_default {bool}
    If true, load all the default doom's lsp configurations. 


lsp.install_sumneko_lua {bool}
    If true, doom will automatically install and setup sumneko_lua. Requires
    the above to be set true.

    Default: true

lsp.servers {table}
    Form: {<server-name> <configuration>}
    If lsp.servers contains any configurations, it will be used to setup. If
    you use {} as config, doom will minimally set it up by itself.

    Default: {"solargraph" {} 
              "pyright"    {}}


*doom-utils*
Doom utils contain some functions that the user may use in their configuration. 
These functions are contained in `doom.utils`.
Lua users will have to use table indexing by string to access many of these functions
because their names contain '-'.

path-exists({path:str}) *doom.utils.path-exists*
    Returns true if path exists or false. 

    Returns: false or true


list-dir({path:str}) *doom.utils.list-dir*
    If path is valid, returns a table of children or false. 

    Returns: false or list


register({f:function}, {keybinding:bool}) *doom.utils.register*
    Creates a new global function under a random name and returns a string
    that can be used in command mode. 

    If keybinding is true then return a string that can be used in a
    keybinding. This is made separate because often commands used in
    keybindings contain '<CR>', etc that don't work in command mode.

    Returns: string


keys({t:table}) *doom.utils.keys*
    Returns all the keys in a table.

    Returns: list


vals({t:table}) *doom.utils.vals*
    Returns all the values in a table.

    Returns: list


consider-os({os-funcs:table}) *doom.utils.consider-os*
    Table form: {{os} {function}}

    If vim.has({os}) then the corresponding function is called. Return values
    of the function are returned. 

    Returns: anything returned from {function}


rest({v:list}) *doom.utils.rest*
    Returns all the elements except the first one in a list.

    Returns: list


first({v:list}) *doom.utils.first*
    Returns the first element of a list. 

    Returns: first element of {v}


find({t:list} {key:str}) *doom.utils.find*
    Returns the element found in {t} matched by {key}. {key} can be a valid
    regex string also. 

    Returns: Anything found in {t} matched {key}


join_path({[str]}) *doom.utils.join_path*
    List of strings will be concatenated with '/' and returned as a single
    string.

    Returns: string


confp({[str]}) *doom.utils.confp*
    Suffix `stdpath('config')` with list of strings passed ahead. 

    Example: confp('a', 'b', 'c') will return $HOME/.config/nvim/a/b/c

    Returns: string


sed({s:str} {replacement-a:list} {substitute-a:list}) *doom.utils.sed*
    Works like GNU sed. This replaces all the strings according to patterns mentioned in
    {replacement-a} with strings mentioned in {substitute-a}.

    Asserts: length(replacement-a) == length(substitute-a)

    Returns: string


linenum([{bufnr:int}]) *doom.utils.linenum*
   Returns the 1-indexed line number (this is the line number that you see) of
   the current buffer is {bufnr} is missing or line number of the buffer
   associated with bufnr. 

   Returns: integer


vpos([{bufnr:int}]) *doom.utils.vpos*
    Returns the starting and ending line number of the visual selection in a
    buffer mentioned by bufnr. If no bufnr is provided, the current buffer
    will be used. 

    Returns: list(int, int)


eval-at-line([{bufnr:int}] [{lineno:int}] {cmd:function/string}) *doom.utils.eval-at-line*
    If {bufnr} is missing, use current buffer. If {lineno} is missing, use
    current line number and execute {cmd} at that line. 

    If {cmd} is a function, the string representation will be obtained via
    |doom.utils.register| or if cmd is a string, use it as is. 

    Returns: nil


set-text([{bufnr:int}] {start-coordinates:list} {end-coordinates:list} {s:str/list}) *doom.utils.set-text*
    If {bufnr} is missing, use current buffer.

    {start-coordinates} and {end-coordinates} should be lists. 

    {s} should be a non-newline-containing string or a list of strings. The
    strings should not have a newlines. 

    The coordinates will be used to set the provided text in the buffer
    specified by default or provided value of {bufnr}.

    Form: 
    {start-coordinates} [<start-row> <start-column>]
    {end-coordinates}   [<end-row> <end-column>]
    {s}                 <string>/[<string>]

    Returns: 
    nil


set-lines([{bufnr:int}] {coordinates:list} {s:str/list}) *doom.utils.set-lines*
    Coordinates should be in the form: [<start-line> <end-line>]. String
    specification is the same as |doom.utils.set-text|. String[s] are set in
    the buffer specified by default or user value of {bufnr}.

    Returns: nil


save-excursion([{bufnr:int}] {f:function}) *doom.utils.save-excursion*
    Function will be executed in the buffer specified by {bufnr} and return
    the cursor position before that function is executed. 

    Returns: Anything from {f}


get-line-count([{bufnr:int}]) *doom.utils.get-line-count*
    Get the number of lines in buffer specified by default or user value of
    {bufnr}.

    Returns: integer


get-buf-name([{bufnr:int}]) *doom.utils.get-buf-name*
    Get the name of the current buffer or user value of {bufnr}.  

    Returns: string


buffer-string([{bufnr:int}] {coordinates:list} {concat:bool}) *doom.utils.buffer-string*
    Get the strings according to {coordinates} in the form: 
    [<start-line> <end-line>]. If {concat} is true then return a
    newline-concatened string obtained or return a table. 

    Returns: string/list


vtext([{concat:bool}]) *doom.utils.vtext*
    Get the text specified in visual selection. If {concat} is true, return a
    newline concateneted string. 

    Returns: string/list


line-range-exec({cmd:string/function}) *doom.utils.line-range-exec*
    Execute {cmd} on every line specified in a visual selection. 

    Returns: nil


respect-count({cmd:str/function} {newline:bool} {keybinding:bool}) *doom.utils.respect-count*
    This makes a command respect `v:count`. Basically a count can be specified
    for a command. If {newline} is true, the command is executed on the next
    consecutive lines. If not, the command will executed `v:count` times on the
    same line. If {keybinding} is true then return a string that can be used
    in a keybinding else return a string that can be command mode. 

    Returns: string


get-line([{bufnr:int}] [{lineno:int}]) *doom.utils.get-line*
    Returns the string at {lineno} in {bufnr}.  

    Returns: string


to-temp-buffer({s:str/list} {direction:str}) *doom.utils.to-temp-buffer*
    Open a window that exits as soon user leaves it. This window is split
    according to {direction} where the default direction is "sp" (split). 

    String specification is the same as |doom.utils.set-text|. 

    Returns: nil

     

sh({s:str} [{buf:bool}])  *doom.utils.sh*   
    Synchronously execute a bash command in {s}. If {buf} is true then open a
    temporary buffer and show the output else simply echo the output. Returns
    the output obtained. 

    Returns: string 
    

autocmd({group:str} {event:str} {pattern:str} {exec:str/function}) *doom.utils.autocmd*
    This is very similar to vim's `autocmd`. {group} is the name of the group
    to hook to {exec}. {event} is the triggering event of {exec}. Patterns
    pertaining to {event} are used to match the parameters to execute {exec}. 

    Returns: nil


augroup({name:str} [{autocmd-forms:list}]) *doom.utils.augroup*
    Create a new augroup and make autocmds based on this group if
    {autocmd-forms} is a list of parameters acceptable to
    |doom.utils.autocmd|. If no {autocmd-forms} exist then make an empty
    augroup.

    Returns: nil


add-hook([{groups:str/list}] [{events:str/list}] [{patterns:str/list}] {exec:str/function}) *doom.utils.add-hook*
    Doom recommends you to use this function instead of |doom.utils.autocmd|. 
    This function can be thought of |doom.utils.autocmd| on steriods. Multiple
    {groups}, {events} and {patterns} can be specified to use with {exec}.
    This function will create all the necessary autocmds for the user.

    Returns: nil


register-to-wk({keys:str} {help:str} [{help-desc:str}] [{not-register}]) *doom.utils.register-to-wk*
    Register to display in which-key popup at keypress. {keys} are normal key
    declarations without attributes that you would use in `map`. {help} is
    string to show for {keys}.

    If {help-desc} is specified, the prefix key for {keys} will also be
    documented in which-key popup. 

    If {not-register} is true then return the table that can be used with: 
    `require('which-key').register` manually by the user.

    Returns: nil or which-key table.
    
    
define-key({opts:table}) *doom.utils.define-key*   
    {opts} have the following keys:
        [{noremap:bool}] 
        Make a non-recursive keybinding? 
        Default: true

        [{key-attribs:list}]
        List of keybinding attributes such as `{buffer} {silent} ...`
        Just pass the name of the attribute or a list of attributes without
        the surround braces. eg "buffer" or ["buffer" "silent"]
        Default: silent

        {keys:str}
        Keys to map depending on {noremap} and {modes}

        [{modes:str/list}]
        Modes to bind to
        Default: ["n"]

        [{events:str/list}]
        Bind the keybinding to these events. This also requires {patterns} to
        be passed by the user.
        Default: nil. 

        [{patterns:str/list}]
        Make an event-based keybinding based on patterns acceptable to the
        bound event. This requires {events} to be passed.
        Default: nil

        [{groups:str/list}]
        These are the groups that an event-based keybinding will be bound to. 
        Default: nil. If {events} and {patterns} are set then "GlobalHook" is
        the default group sed.

        {exec:str/function}
        Use this str or function in the keybinding. 

        [{help:str}] 
        Help string to show in which-key popup
        Default: nil

        [{help-group:str}]
        Description of the prefix of {keys}
        Default: nil

        [{repeatable:bool}]
        Make the keybinding repeatable? 
        Default: false

    Returns: nil

     
define-keys({...}) *doom.utils.define-keys*
    Wrapper for |doom.utils.define-key| except that it can accept any number
    of forms required by |doom.utils.define-key|.

    Returns: nil


convert-to-lua([{filename:list}])  *doom.utils.convert-to-lua*  
    This compiles the default or user fennel filenames present in `~/.vdoom.d/fnl`
to lua. The compiled file is saved in `~/.vdoom.d/compiled`.

    The default filenames are present in |doom.user_compile_fnl|.

    Returns: nil


try-then-else({try-f:function} {success-f:function} {failure-f:function})  *doom.utils.try-then-else*
    If {try-f} does not throw errors then {success-f} will be called and 
    its returns values will be returned else {failure-f} will be called and
    its return values will be returned.

    Returns: anything from {success-f} or {failure-f}


try-catch-then({try-f:function} {handle-f:function} [{then-f:function}])  *doom.utils.try-catch-then*
    If {try-f} emits an error then {handle-f} is used to handle it. 
    If {then-f} is passed, {then-f} is called at the end of handling.

    Returns: anything from {then-f} if it is supplied or nil


try-require({module-name} {type-module}) *doom.utils.try-require*   
    Try to require {module-name}. If it throws errors, the error is logged in
    `stdpath('data')/doom-evim.log`. {type-module} can be any string. doom
    uses "DOOM" for its error handling and by user modules use "USER".

    Returns: nil


*doom-lsp-configs*
Module `lsp-configs` does not contain any useful functions that will be
required for general tasks. On the other hand, it contains some defaults that
can aid the users in setting up their LSP configuration quickly. 

Associated configuration:
    doom.lsp.install_sumneko_lua 
    doom.lsp.load_default 
    doom.lsp.servers

Functions available: 
    - on-attach-f 
      This function is used in initializing servers with nvim-lspconfig. You
      can use this function instead of copying the on-attach function from
      nvim-lspconfig's repo.

Other than that, this module sets up a bunch of keybindings to use with
neovim's builtin LSP. 

*doom-logger*
This modules presents 5 to use for logging. Doom's log file is present at
`stdpath('data')/doom-evim.log`.

log({level:str} {message:str}) *doom.logger.log*
    Level should one of debug, info, error, fatal or warn. Message should be a
    string to log. 

dlog({message:str})
    Translates to log(:debug, message)

elog({message:str})
    Translates to log(:error, message)

flog({message:str})
    Translates to log(:fatal, message)

ilog({message:str})
    Translates to log(:info message)

*doom-repl*
This module contains stuff to make doom's repl work. This module exposes some
functions which can be used by the user. Other than that, the module sets up a
couple of keybindings to <localleader>. It also provides a very basic debugger
which just splits the buffer and launches the script with its filetype's
associated debugger.

Associated configuration:
    doom.repl.ft 
    doom.repl.running_repls 

Associated commands:
    :REPLNew {cmd:str} *REPLNew*
        Start a new REPL using {cmd}
    
    :REPLSend {cmd:str} {s:str} *REPLSend*
        Send {cmd} associated REPL string {s} if it is not one of line, visual,
        till-point or buffer. 

        If {s} is
            :line       Send current line
            :till-point Send everything until cursor
            :visual     Send the visual selection
            :buffer     Send the whole buffer

    :REPLSplit {cmd:str} *REPLSplit*
        Split current window and launch and REPL using {cmd}. 
        If REPL has not been launched, it will done be so. 

    :REPLVsplit {cmd:str} *REPLVsplit*
        Vertically split current window and launch and REPL using {cmd}. 
        If REPL has not been launched, it will done be so. 

    :REPLTab {cmd:str} *REPLTab*
        Open REPL with {cmd} in a new tab. 

    :REPLTabShell *REPLTabShell*
        Equals :REPLTab bash

    :REPLVsplitShell *REPLVsplitShell* 
        Equals :REPLVsplit bash

    :REPLSplitShell *REPLSplitShell*
        Equals :REPLSplit bash

    :REPLShellSend {s:str} *REPLShellSend*
        Equals :REPLSend bash {s}

    :StartDebugger [{cmd:str}] *StartDebugger*
        Start a debugger with command {cmd}. If {cmd} is unspecified,
        `doom.langs.<filetype>.debug` will be queried to get the debugger for
        current filetype. If none is found, the command will fail.

    :SplitDebugger [{cmd:str}] *SplitDebugger*
        Command specifications are same as |StartDebugger|.
        Split current window and open terminal with the debugger.

    :VsplitDebugger [{cmd:str}] *VsplitDebugger*
        Command specifications are same as |StartDebugger|.
        Vertically split current window and open terminal with the debugger.
 
    :DebuggerSend {what:str} [{cmd:str}] *DebuggerSend*
        Command specifications are same as |StartDebugger|.
        {what} specifications are same as |REPLSend|
        Send {what} to debugger in a terminal.

    :KillDebugger [{cmd:str}] *KillDebugger*
        Command specifications are same as |StartDebugger|.
        {cmd} is used to get the running debugger to kill it.

    :GetDebugger *GetDebugger*
        Get the debugger for the current file.

Functions are analogous to commands accept shutdown and shutdown-all.
Here are the mappings:

buffer-new -> |REPLNew|
    Also accepts an additional {id} parameter that is used to index the job id
    of the associated REPL.

split -> |REPLSplit|

vsplit -> |REPLVsplit|

tabnew -> |REPLTab|

shutdown {cmd:str}
    Shuts down the {cmd} associated REPL. 

shutdown-all
    Shuts down all REPLs

split-shell -> |REPLSplitShell|

vsplit-shell -> |REPLVsplitShell|

tabnew-shell -> |REPLTabShell|

... I suppose that you can figure out the rest of the mappings. 
You can check the source file yourself. It won't be that difficult. I promise.


*doom-runner*
This module has no functions that can be used by the user. However, it will
explain the purpose of this module.

Oftentimes you need to compile some stuff and you have to unnecessarily open
the terminal for that single task. doom-runner provides you with commands to
simply do that in an async job. 

There are 3 types of runners supported: 
    compile
        Used to compile the current file. Compile means simply running the
        current file using its interpreter.

    test
        Used to run suite tests. You can specify the base command and later
        provide additional args for the same. 

    build
        Used to build stuff. You can specify the base command and later
        provide additional args for the same. 

All the runners will be defined in |doom.langs|. If you want to simple compile
the current file then just add a {compile} key to |doom.langs|. 


*doom-packages*
This module has nothing the user can use. This module defines some keybindings
for doom's package manager packer and makes the final list to pass to packer
for initializing packages.

Associated globals:
    doom.packages [table]
        Contains the master list of all the packages passed to packer.startup

    doom.user_packages [table]
        Contains the table obtained from `user-packages.lua`.

Furthermore, `specs` and `user-specs` are also required which configure post
and pre package-init hooks. 

Associated functions:
    after! {packages:list/str} {f:function} *after!*
        If all the {packages} provided are present in doom.packages, {f} is
        called. This only occurs after all the packages are initialized.

    specs! {package:str} {t:table} *specs!*
        Configure a {package} using {t}. {t}'s specs should conform with
        `packer.use`.


*doom-dap*
This module contains nothing that can be used by the user. It sets up DAP with
vimspector for doom and sets up keybindings. 

Associated Globals:
    doom.dap.default 
        Contains a list of dap servers to install by default when function 
        `dap-config.install-default`is called.

Your vimspector filetype configurations are to be put in
`stdpath('data')/vimspector/<filetype>/default.json`

If you have not specified any then doom comes with its own configurations for
lua, python and javascript which will be used otherwise.
not one. These are present in
`~/.config/nvim/support/vimspector/<filetype>/default.json`

However, if there is a .vimspector.json in the workspace directory of the
script then nothing is copied and that file is used.

If you want to install all the langs that have been configured by doom, 
first require 'dap-config' and run `dap-config.install-default`. Otherwise,
you can simply `:VimspectorInstall <debugger>` yourself.


*doom-default-packages*
These are the packages that are shipped with doom. Only the essentials are
installed and the rest are installed by :PackerInstall at first startup.
>
Master list: 
>
    -- essentials
    packer.nvim                     | The default package manager for doom         
    vimpeccable                     | Required for keymappings   
    plenary.nvim                    | Very important module used by many packages
    aniseed                         | Extra goodies for fennel   
    conjure                         | An REPL for fennel, hy, clojure, etc 
    fennel.vim                      | Syntax highlighting for fennel   
    which-key.nvim                  | Show keymappings in a popup window 
    Repeatable.vim                  | Make keybindings Repeatable   

    -- ui
    dashboard-nvim                  | A beautiful startup screen for vim
    galaxyline.nvim                 | A simple modeline for doom   
    vim-palette                     | Plenty of colorschemes included   
    vim-devicons                    | Important UI icons   
    nvim-web-devicons               | Important UI icons   
    telescope.nvim                  | Ivy-like dropdown menu functionality   
    telescope-project.nvim          | Project extension for telescope   
    telescope-file-browser.nvim     | File browser extension for telescope
    zen-mode.nvim                   | Distraction-free coding/writing   
    twilight.nvim                   | Extension for zen-mode.nvim   
    nvim-tree.lua                   | File tree for nvim   

    -- editor
    formatter.nvim                  | Automatically format your file    
    vim-misc                        | Necessity for vim-vsnip
    vim-bbye                        | Intelligently delete buffers without shutting vim   
    vim-dispatch                    | Async dispatcher for nvim   
    tagbar                          | Show a tagbar beside the script window   
    undotree                        | A better undo-redo implementation   
    nerdcommenter                   | Easy commenting!   
    vim-markdown                    | Markdown syntax for vim   
    markdown-preview.nvim           | Preview markdown in your file browser.    
    vim-surround                    | Quickly surround text with text   
    delimitMate                     | For autoclosing parenthesis of most kinds   
    indent-blankline.nvim           | Show indent-guide for blanklines   
    tabular                         | Quickly align    
    vim-projectionist               | For better project management   
    vim-sexp                        | Smartparens for vim   
    persistence.nvim                | Make your sessions persistent across startups   

    -- git
    vim-fugitive                    | Magit's counterpart for vim   
    vim-rhubarb                     | Quickly push commits without reopening the browser   
    gitsigns.nvim                   | Show git gutter in the signcolumn   

    -- lsp
    trouble.nvim                    | No more annoying virtual text for LSP. 
    vimspector                      | For using DAP in vim   

    -- treesitter
    nvim-lspconfig                  | Default LSP configurations   
    nvim-treesitter                 | Treesitter syntax highlighting   
    nvim-lsp-installer              | Install treesitter parsers   

    -- snippets
    friendly-snippets               |    
    vim-vsnip                       |    
    cmp-vsnip                       |    
    vim-vsnip-integ                 |    
    cmp-nvim-lsp                    | These are all snippets-related packages.   
    cmp-buffer                      |    
    cmp-path                        |    
    cmp-cmdline                     |    
    nvim-cmp                        |    

    -- langs
    vim-rails                       | For ruby-on-rails
    nvim-luapad                     | Interested in seeing quick evaluations of lua expressions?   


*doom-package-groups*
Doom uses groups of these packages to configure a certain functionality. Many
times if you remove even one package, an entire functionality won't be
working. These are the groups used: 

    Doom's LSP configuration: >
        nvim-lspconfig 
        nvim-treesitter
        nvim-lsp-installer
        nvim-cmp
        cmp-nvim-lsp
        cmp-vsnip
        vim-vsnip
        trouble.nvim
        cmp-buffer
        cmp-path
        cmp-cmdline
<
    Doom's telescope configuration: >
        telescope.nvim
        telescope-project.nvim
        telescope-file-browser.nvim
<
Rest of the packages are not configured in groups.


==============================================================================
KEYBINDINGS *doom-keybindings*

Keybindings are quite easy to make. You have to use |doom.utils.define-key| for a
single keybinding and |doom.utils.define-keys| for binding multiple keys. If you
want to make you keybinding respect v:count, then wrap the command in
|doom.utils.respect-count|. If you want you keybinding to work on the lines in
a visual selection, use |doom.utils.line-range-exec|.

Below are the list of default keybindings that doom comes with.

Font operations:
>
    {:keys "<C-ScrollWheelUp>"
     :help "Increase font size by 2}

    {:keys "<C-ScrollWheelDown>"
     :help "Decrease font size by 2}

File operations: 
>
    {:keys "<leader>fs"
     :help "Save curent file"}
    
    {:keys "<leader>fv"
     :help "Source current file"}
    
    {:keys "<leader>fp"
     :help "Open doom config dir"}
    
    {:keys "<leader>fP"
     :help "Open private config dir"}
    
    {:keys "<leader>fV"
     :help "Source doom's init.lua"}
<
Tab operations:
>
    {:keys "<leader>tk"
     :help "Close current tab"}
    
    {:keys "<leader>tn"
     :help "Go to next tab"}
    
    {:keys "<leader>tp"
     :help "Go to previous tab"}
    
    {:keys "<leader>tf"
     :help "Find tab"}
    
    {:keys "<leader>te"
     :help "Open file in a new tab"}
    
    {:keys "<leader>tt"
     :help "Open a new tab"}
<    
Buffer operations:
>
    {:keys "<leader>qw"
     :help "Save buffers and quit"}
    
    {:keys "<leader>bp"
     :help "Previous buffer"}
    
    {:keys "<leader>bn"
     :help "Next buffer"}
    
    {:keys "<leader>br"
     :help "Revert buffer"}
    
    {:keys "<leader>bk"
     :help "Hide current buffer"}
    
    {:keys "<leader>qq"
     :help "Quit unconditionally"}
    
    {:keys "<del>"
     :help "No highlight"}
<
Misc operations:
>
    {:keys "<leader>;"
     :help "Open command mode"}
    
    {:keys "!"
     :help "Execute an sh command"}
<
    
Clipboard operations:
>
    {:keys "<leader>xp"
     :help "Paste from clipboard"

    {:keys "<leader>hrr"
     :help "Reload doom"}
                     
Indentation:
>
     {:keys "<PageDown>"
      :help "Decrease indent"}

     {:keys "<PageUp>"
      :help "Increase indent"}

     {:keys "<S-PageDown>"
      :modes ["v"]
      :help "Decrease indent in range"}

     {:keys "<S-PageUp>"
      :modes ["v"]
      :help "Increase indent in range"}

Doom REPL:
>
    {:keys "<localleader>,t"
     :help "Open a ft REPL in a new tab"}
    
    {:keys "<localleader>,T"
     :help "Open a new bash REPL in a new tab"}
    
    {:keys "<localleader>mee"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>me."
     :help "Send strings till-point to ft REPL"}
    
    {:keys "<localleader>meb"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>meE"
     :help "Send current line to bash REPL"}
    
    {:keys "<localleader>me>"
     :help "Send strings till-point to bash REPL"}
    
    {:keys "<localleader>meB"
     :help "Send current line to ft REPL"}
    
    {:keys "<localleader>meE"
     :modes "v"
     :help "Send visual range to bash REPL"}
    
    {:keys "<localleader>mee"
     :modes "v"
     :help "Send visual range to ft REPL"}
    
    {:keys "<localleader>ts" 
     :help "Split buffer and open shell"}
    
    {:keys "<localleader>tv" 
     :help "Split buffer and open shell"}
    
    {:keys "<localleader>,s" 
     :help "Split buffer and open ft REPL"}
    
    {:keys "<localleader>,v" 
     :help "Vsplit buffer and open ft REPL"}
    
    {:keys "<localleader>,k"
     :help "Shutdown current ft REPL"}
    
    {:keys "<localleader>,K"
     :help "Shutdown all REPLs"}
    
    {:keys "<localleader>tk"
     :help "Shutdown bash shell"}

Doom runner:
>
    {:keys "<leader>mC" 
     :help "Compile <lang>"}

    {:keys "<leader>mB"
     :help "Build <lang>"}

    {:keys "<leader>mT"
     :help "Test <lang>"}

    {:keys "<leader>mc"
     :help "Compile buffer file"}

    {:keys "<leader>mb"
     :help "Build buffer file"}

    {:keys "<leader>mt"
     :help "Compile buffer file"}

nvim-tree.lua:
>
    {:keys "<leader>`" 
     :help "Open nvim-tree" }

vimspector:
>
    {:keys "<leader>de"
     :help "Reset vimspector"}
    
    {:keys "<leader>dc"
     :help "Continue"}
    
    {:keys "<leader>dt"
     :help "Toggle breakpoint"}
    
    {:keys "<leader>dT"
     :help "Clear breakpoints"}
    
    {:keys "<leader>dk"
     :help "Restart vimspector"}
    
    {:keys "<leader>dh"
     :help "Step out/finish"}
    
    {:keys "<leader>dl"
     :help "Step in/step"}
    
    {:keys "<leader>dj"
     :help "Step over/next"}

persistence.nvim:
>
    {:keys "<leader>sl"
     :help "Load session"}
    
    {:keys "<leader>ss"
     :help "Load session"}

trouble.nvim:
>
    {:keys "<leader>lt" 
     :help "Toggle trouble"}

zen-mode.nvim
>
    {:keys "<leader>bz" 
     :help "Activate ZenMode"}

telescope.nvim, 
telescope-project.nvim,
telescope-file-browser.nvim:
>
    {:keys "<leader>ff"
     :help "Find file"}
    
    {:keys "<localleader>/"
     :help "Live grep in cwd"}
    
    {:keys "<leader>/"
     :help "Grep string in cwd"}
    
    {:keys "<leader>fg"
     :help "Show git files"}
    
    {:keys "<leader>hk"
     :help "Show keymaps"}
    
    {:keys "<leader>ht"
     :help "Select theme"}
    
    {:keys "<leader>bb"
     :help "Show buffers"}
    
    {:keys "<leader>fr"
     :help "Show old files"}
    
    {:keys "<A-x>"
     :help "Show commands"}
    
    {:keys "<leader>hr"
     :help "Show command history"}
    
    {:keys "<leader>sr"
     :help "Show search history"}
    
    {:keys "<leader>hm"
     :help "Show man page for a program"}
    
    {:keys "<leader>hj"
     :help "Show jumplist"}
    
    {:keys "<leader>h\""
     :help "Show all registers"}
    
    {:keys "<M-y>"
     :help "Show all registers"}
    
    {:keys "<leader><leader>s"
     :help "Resume telescope"}
    
    {:keys "<leader>hq"
     :help "Show quickfix list"}
    
    {:keys "<leader>lhr"
     :help "Show references"}
    
    {:keys "<leader>lhs"
     :help "Document symbols"}
    
    {:keys "<leader>lhw"
     :help "Show workspace symbols"}
    
    {:keys "<leader>lhW"
     :help "Show dynamic ws symbols"}
    
    {:keys "<leader>lhc"
     :help "Show code actions"}
    
    {:keys "<leader>lhr"
     :help "Show range code actions"}
    
    {:keys "<leader>lhd"
     :help "Show diagnostics"}
    
    {:keys "<leader>lhi"
     :help "Show LSP implementations"}
    
    {:keys "<leader>lhd"
     :help "Show LSP definitions"}
    
    {:keys "<leader>lht"
     :help "Show type definitions"}
    
    {:keys "<leader>mhs"
     :help "Show treesitter symbols"}
    
    {:keys "<leader>ghc"
     :help "Show commits"}
    
    {:keys "<leader>ghC"
     :help "Show branch commits"}
    
    {:keys "<leader>ghb"
     :help "Show branches"}
    
    {:keys "<leader>ghs"
     :help "Show status"} 
    
    {:keys "<leader>ghS"
     :help "Show stashes"}
    
    {:keys "<leader>fF"
     :help "Open file browser"}
    
    {:keys "<leader>pp"
     :help "Open project"}

tagbar:
>
    {:keys "<C-t>"
     :exec ":TagbarToggle<CR>"}

vim-fugitive:
>
    {:keys "<leader>gg" 
     :help "Open Fugitive in cwd"}
    
    {:keys "<leader>gi" 
     :help "Initialize git in cwd"}
    
    {:keys "<leader>ga" 
     :help "Track current file"}
    
    {:keys "<leader>gs" 
     :help "Stage current file"}
    
    {:keys "<leader>gc" 
     :help "Commit changes"}
    
    {:keys "<leader>gp" 
     :help "Push commits"}
    
    {:keys "<leader>gm" 
     :help "Merge from remote"}

nvim-luapad:
>
    {:keys "<F3>"
     :help "Start Luapad"}

vim-bbye:
>
    {:keys "<leader>bq"
     :help "Delete current buffer"}


==============================================================================
CAVEATS *doom-caveats*

This section contains some caveats that users should keep in mind:

Regarding user fennel configuration:
    - Do not use modules in your configuration files. 
      For some reason, fennel is unable to compile the module string. 
      Simply make a local var and then return it at the end of the file.

Regarding private configuration:
    Under any circumstances, ensure that `user-packages.lua`  is present in
    the file path. Without this file, doom will crash.

Regarding doom's configuration:
    - Do not modify global variables unnecessarily if you don't know what they
      do. If you are a new user, better stick to the ones already defined in
      |doom-globals|.

Regarding packages:
    - Any packages added or removed will be quickly reflected after you start
      doom. Do not remove the essentials or else doom will fail to start. 
    - Keep in mind |doom-package-groups| while removing packages

Regarding LSP:
    - Default LSP can be disabled and other LSP clients can be used. That's
      OK. However, you won't get any nvim-cmp functionality either. So keep
      that in mind. 
